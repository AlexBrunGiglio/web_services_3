import { SelectQueryBuilder } from "typeorm";
import { ComparableValue } from "../types/ComparableValue";
import { EntityBase } from "../types/EntityBase";
import { JoinedEntityType } from "../types/JoinedEntityType";
import { QueryConditionOptions } from "../types/QueryConditionOptions";
import { QueryOrderOptions } from "../types/QueryOrderOptions";
import { IComparableQuery } from "./interfaces/IComparableQuery";
import { IJoinedComparableQuery } from "./interfaces/IJoinedComparableQuery";
import { IJoinedQuery } from "./interfaces/IJoinedQuery";
import { IQuery } from "./interfaces/IQuery";
import { IQueryBuilderPart } from "./interfaces/IQueryBuilderPart";
import { IQueryInternal } from "./interfaces/IQueryInternal";
import { ISelectQuery } from "./interfaces/ISelectQuery";
import { ISelectQueryInternal } from "./interfaces/ISelectQueryInternal";
export declare class Query<T extends EntityBase, R extends T | T[], P = T> implements IQuery<T, R, P>, IJoinedQuery<T, R, P>, IComparableQuery<T, R, P>, IJoinedComparableQuery<T, R, P>, IQueryInternal<T, R, P>, ISelectQueryInternal<T, R, P> {
    private readonly _duplicateAliasHistory;
    private readonly _getAction;
    private readonly _includeAliasHistory;
    private readonly _initialAlias;
    private readonly _query;
    private readonly _queryParts;
    private _lastAlias;
    private _queryMode;
    private _queryWhereType;
    private _selectedProperty;
    /**
     * Constructs a Query wrapper.
     * @param queryBuilder The QueryBuilder to wrap.
     * @param getAction Either queryBuilder.getOne or queryBuilder.getMany.
     */
    constructor(queryBuilder: SelectQueryBuilder<T>, getAction: () => Promise<R>, includeAliasHistory?: string[]);
    get getAction(): () => Promise<R>;
    get query(): SelectQueryBuilder<T>;
    get queryParts(): IQueryBuilderPart<T>[];
    get selected(): string;
    and<S extends Object, PP = P, RR = P>(propertySelector: (obj: PP) => S): IComparableQuery<T, R, RR>;
    andAny<S extends Object>(relationSelector: (obj: T) => JoinedEntityType<S>, relationCountPropSelector: (obj: S) => ComparableValue, conditionPropSelector?: (obj: S) => ComparableValue): any;
    andNone<S extends Object>(relationSelector: (obj: T) => JoinedEntityType<S>, relationCountPropSelector: (obj: S) => ComparableValue, conditionPropSelector?: (obj: S) => ComparableValue): any;
    beginsWith(value: string, options?: QueryConditionOptions): IQuery<T, R, P>;
    catch(rejected: (error: any) => void | Promise<any> | IQuery<any, any>): Promise<any>;
    contains(value: string, options?: QueryConditionOptions): IQuery<T, R, P>;
    count(): Promise<number>;
    endsWith(value: string, options?: QueryConditionOptions): IQuery<T, R, P>;
    equal(value: ComparableValue, options?: QueryConditionOptions): IQuery<T, R, P>;
    equalJoined(selector: (obj: P) => any, options?: QueryConditionOptions): IQuery<T, R, P>;
    from<F extends {
        id: number;
    }>(foreignEntity: {
        new (...params: any[]): F;
    }): IJoinedQuery<T, R, F> | IComparableQuery<T, R, F> | any;
    greaterThan(value: number | Date): IQuery<T, R, P>;
    greaterThanJoined(selector: (obj: P) => any): IQuery<T, R, P>;
    greaterThanOrEqual(value: number | Date): IQuery<T, R, P>;
    greaterThanOrEqualJoined(selector: (obj: P) => any): IQuery<T, R, P>;
    groupBy(propertySelector: (obj: P) => any): IQuery<T, R, P>;
    in(include: string[] | number[], options?: QueryConditionOptions): IQuery<T, R, P>;
    include<S>(propertySelector: (obj: T) => JoinedEntityType<S>): IQuery<T, R, S>;
    inSelected<TI extends {
        id: number;
    }, RI extends TI | TI[], PI1 = TI>(innerQuery: ISelectQuery<TI, RI, PI1>): IQuery<T, R, P>;
    isFalse(): IQuery<T, R, P>;
    isNotNull(): IQuery<T, R, P>;
    isNull(): IQuery<T, R, P>;
    isolatedAnd<S extends Object>(and: (query: IQuery<T, R, P>) => IQuery<T, R, S>): IQuery<T, R, P>;
    isolatedOr<S extends Object>(and: (query: IQuery<T, R, P>) => IQuery<T, R, S>): IQuery<T, R, P>;
    isolatedWhere<S extends Object>(where: (query: IQuery<T, R, T>) => IQuery<T, R, S>): IQuery<T, R, T>;
    isTrue(): IQuery<T, R, P>;
    join<S extends Object>(propertySelector: (obj: T) => JoinedEntityType<S>): IQuery<T, R, S> | IComparableQuery<T, R, S> | any;
    joinAlso<S extends Object>(propertySelector: (obj: T) => JoinedEntityType<S>): IQuery<T, R, S> | IComparableQuery<T, R, S> | any;
    lessThan(value: number | Date): IQuery<T, R, P>;
    lessThanJoined(selector: (obj: P) => any): IQuery<T, R, P>;
    lessThanOrEqual(value: number | Date): IQuery<T, R, P>;
    lessThanOrEqualJoined(selector: (obj: P) => any): IQuery<T, R, P>;
    notEqual(value: ComparableValue, options?: QueryConditionOptions): IQuery<T, R, P>;
    notEqualJoined(selector: (obj: P) => any, options?: QueryConditionOptions): IQuery<T, R, P>;
    notIn(exclude: string[] | number[], options?: QueryConditionOptions): IQuery<T, R, P>;
    notInSelected<TI extends {
        id: number;
    }, RI extends TI | TI[], PI1 = TI>(innerQuery: ISelectQuery<TI, RI, PI1>): IQuery<T, R, P>;
    or<S extends Object>(propertySelector: (obj: P) => S): IComparableQuery<T, R, P>;
    orAny<S extends Object>(relationSelector: (obj: T) => JoinedEntityType<S>, relationCountPropSelector: (obj: S) => ComparableValue, conditionPropSelector?: (obj: S) => ComparableValue): any;
    orderBy(propertySelector: (obj: P) => any, options?: QueryOrderOptions): IQuery<T, R, P>;
    orderByDescending(propertySelector: (obj: P) => any, options?: QueryOrderOptions): IQuery<T, R, P>;
    orNone<S extends Object>(relationSelector: (obj: T) => JoinedEntityType<S>, relationCountPropSelector: (obj: S) => ComparableValue, conditionPropSelector?: (obj: S) => ComparableValue): any;
    reset(): IQuery<T, R, T>;
    select(propertySelector: (obj: any) => any): ISelectQuery<T, R, T> | ISelectQuery<T, R, P>;
    skip(skip: number): IQuery<T, R, P>;
    take(limit: number): IQuery<T, R, P>;
    then(resolved: (results: R) => void | Promise<any>): Promise<any>;
    thenBy(propertySelector: (obj: P) => any, options?: QueryOrderOptions): IQuery<T, R, P>;
    thenByDescending(propertySelector: (obj: P) => any, options?: QueryOrderOptions): IQuery<T, R, P>;
    thenGroupBy(propertySelector: (obj: P) => any): IQuery<T, R, P>;
    thenInclude<S extends Object>(propertySelector: (obj: P) => JoinedEntityType<S>): IQuery<T, R, S>;
    thenJoin<S extends Object>(propertySelector: (obj: P) => JoinedEntityType<S>): IQuery<T, R, S> | IComparableQuery<T, R, S> | any;
    thenJoinAlso<S extends Object>(propertySelector: (obj: P) => JoinedEntityType<S>): IQuery<T, R, S> | IComparableQuery<T, R, S> | any;
    toPromise(): Promise<R>;
    usingBaseType(): IQuery<T, R, T>;
    where<S extends Object, F = T | P>(propertySelector: (obj: F) => S): IComparableQuery<T, R, T> | IComparableQuery<T, R, P> | any;
    whereAny<S extends Object>(relationSelector: (obj: T) => JoinedEntityType<S>, relationCountPropSelector: (obj: S) => ComparableValue, conditionPropSelector?: (obj: S) => ComparableValue): any;
    whereNone<S extends Object>(relationSelector: (obj: T) => JoinedEntityType<S>, relationCountPropSelector: (obj: S) => ComparableValue, conditionPropSelector?: (obj: S) => ComparableValue): any;
    private addJoinCondition;
    private andOr;
    private buildQuery;
    private compileQueryParts;
    private completeGroupBy;
    private completeOrderBy;
    private completeJoinedWhere;
    private completeWhere;
    private createJoinCondition;
    private escapeStringArray;
    private includeOrExcludeFromInnerQuery;
    private includePropertyUsingAlias;
    private isolatedConditions;
    private joinForeignEntity;
    private joinMultipleProperties;
    private joinOrIncludePropertyUsingAlias;
    private joinPropertyUsingAlias;
    private relationCount;
    private setJoinIfNotCompare;
}
