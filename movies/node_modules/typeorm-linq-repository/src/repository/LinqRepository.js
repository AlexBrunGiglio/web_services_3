"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LinqRepository = void 0;
const ts_simple_nameof_1 = require("ts-simple-nameof");
const typeorm_1 = require("typeorm");
const Query_1 = require("../query/Query");
/**
 * Base repository operations for TypeORM entities.
 */
class LinqRepository {
    /**
     * Constructs the repository for the specified entity with, unless otherwise specified,
     * a primry key named "id" that is auto-generated.
     * @param entityType The entity whose repository to create.
     * @param options Options for setting up the repository.
     */
    constructor(entityType, options) {
        let autoGenerateId = true;
        let connectionName;
        let primaryKeyName = "id";
        if (options) {
            if (typeof (options.autoGenerateId) === "boolean") {
                autoGenerateId = options.autoGenerateId;
            }
            if (options.connectionName) {
                connectionName = options.connectionName;
            }
            if (options.primaryKey) {
                primaryKeyName = ts_simple_nameof_1.nameof(options.primaryKey);
            }
        }
        this._repository = typeorm_1.getConnectionManager()
            .get(connectionName)
            .getRepository(entityType);
        this._autoGenerateId = autoGenerateId;
        this._primaryKeyName = primaryKeyName;
    }
    get typeormRepository() {
        return this._repository;
    }
    create(entities) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._autoGenerateId) {
                // Set "id" to undefined in order to allow auto-generation.
                if (entities instanceof Array) {
                    for (const entity of entities) {
                        // Not sure what is going on with this...
                        // Even defining EntityBase as { [key: string]: any; }
                        // or even Record<string, any> results in the error
                        // "Type 'string' cannot be used to index type T".
                        // https://github.com/microsoft/TypeScript/issues/31661
                        entity[this._primaryKeyName] = undefined;
                    }
                }
                else {
                    // Not sure what is going on with this...
                    // Even defining EntityBase as { [key: string]: any; }
                    // or even Record<string, any> results in the error
                    // "Type 'string' cannot be used to index type T".
                    // https://github.com/microsoft/TypeScript/issues/31661
                    entities[this._primaryKeyName] = undefined;
                }
            }
            return this.upsert(entities);
        });
    }
    createQueryBuilder(alias) {
        return this._repository.createQueryBuilder(alias);
    }
    delete(entities) {
        return __awaiter(this, void 0, void 0, function* () {
            if (typeof (entities) === "number" || typeof (entities) === "string") {
                yield this._repository.delete(entities);
            }
            else {
                yield this._repository.remove(entities);
            }
            return true;
        });
    }
    getAll() {
        const queryBuilder = this.createQueryBuilder("entity");
        const query = new Query_1.Query(queryBuilder, queryBuilder.getMany);
        return query;
    }
    getById(id) {
        const alias = "entity";
        let queryBuilder = this.createQueryBuilder(alias);
        queryBuilder = queryBuilder.where(`${alias}.${this._primaryKeyName} = :id`, { id });
        const query = new Query_1.Query(queryBuilder, queryBuilder.getOne);
        return query;
    }
    getOne() {
        const queryBuilder = this.createQueryBuilder("entity");
        const query = new Query_1.Query(queryBuilder, queryBuilder.getOne);
        return query;
    }
    update(entities) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.upsert(entities);
        });
    }
    upsert(entities) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._repository.save(entities);
        });
    }
}
exports.LinqRepository = LinqRepository;
